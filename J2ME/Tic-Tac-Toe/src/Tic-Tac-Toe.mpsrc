program TicTacToe;
var
    menu_bckg: image; // Фон меню.
    menu_imageOn: image; // Картинка активного пункту меню.
    menu_imageOff: image; // Картинка пасивного пункту меню.
    menu_strings: array[1..4] of string; // Текст пунктів меню.
    menu_item: integer; // На якому пункті меню зараз є фокус.
    location: integer; // Від значення залежить, що буде виконуватися в програмі.
    
    gkey: integer; // Код останньої нажатої клавіші.
    i, j, x, y, w, h: integer; // Допоміжні змінні.
    
    board: array[0..8] of integer; // Значення всіх комірок.
    cells: array[0..8, 0..1] of integer; // Координати всіх комірок. cells[0, 0] - x, cells[0, 1] - y.
    cell_size: integer; // Розмір комірки.
    cursor_pos: integer; // На якій комірці курсор.
    queue: integer; // Чий хід.
    counter: integer; // Кількість ходів.
    counterX: integer; // Кількість виграшів для 'X'.
    counter0: integer; // Кількість виграшів для '0'.
    level: integer; // Рівень ігри.
    
const
    IDX = 1;
    ID0 = 2;
    IDEMPTY = 0;


procedure DrawFigure(figure, x, y: integer);
begin
    SetColor(30, 230, 30);
    if (figure = IDX) then
    begin
        DrawLine(x + 3, y + 3, x + cell_size - 3, y + cell_size - 3);
        DrawLine(x + cell_size - 3, y + 3, x + 3, y + cell_size - 3);
    end
    if (figure = ID0) then
    begin
        DrawEllipse(x + 3, y + 3, cell_size - 6, cell_size - 6);
    end
end;


procedure DrawBoard;
begin
    SetColor(30, 30, 230);
    
    DrawLine(cell_size, 0, cell_size, cell_size * 3);
    DrawLine(cell_size * 2, 0, cell_size * 2, cell_size * 3);
    
    DrawLine(0, cell_size, cell_size * 3, cell_size);
    DrawLine(0, cell_size * 2, cell_size * 3, cell_size * 2);
    
    DrawFigure(board[0], cells[0, 0], cells[0, 1]);
    DrawFigure(board[1], cells[1, 0], cells[1, 1]);
    DrawFigure(board[2], cells[2, 0], cells[2, 1]);
    DrawFigure(board[3], cells[3, 0], cells[3, 1]);
    DrawFigure(board[4], cells[4, 0], cells[4, 1]);
    DrawFigure(board[5], cells[5, 0], cells[5, 1]);
    DrawFigure(board[6], cells[6, 0], cells[6, 1]);
    DrawFigure(board[7], cells[7, 0], cells[7, 1]);
    DrawFigure(board[8], cells[8, 0], cells[8, 1]);
end;


function IsWin: integer;
var
    b_ret: boolean;
    
begin
    IsWin := IDEMPTY;
    b_ret := False;
    
    if (board[0] = IDX) and (board[1] = IDX) and (board[2] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[3] = IDX) and (board[4] = IDX) and (board[5] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[6] = IDX) and (board[7] = IDX) and (board[8] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[0] = IDX) and (board[3] = IDX) and (board[6] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[1] = IDX) and (board[4] = IDX) and (board[7] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[2] = IDX) and (board[5] = IDX) and (board[8] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[0] = IDX) and (board[4] = IDX) and (board[8] = IDX) then begin IsWin := IDX; b_ret := True; end;
    if (board[2] = IDX) and (board[4] = IDX) and (board[6] = IDX) then begin IsWin := IDX; b_ret := True; end;
    
    if (b_ret = False) then
    begin
        if (board[0] = ID0) and (board[1] = ID0) and (board[2] = ID0) then IsWin := ID0;
        if (board[3] = ID0) and (board[4] = ID0) and (board[5] = ID0) then IsWin := ID0;
        if (board[6] = ID0) and (board[7] = ID0) and (board[8] = ID0) then IsWin := ID0;
        if (board[0] = ID0) and (board[3] = ID0) and (board[6] = ID0) then IsWin := ID0;
        if (board[1] = ID0) and (board[4] = ID0) and (board[7] = ID0) then IsWin := ID0;
        if (board[2] = ID0) and (board[5] = ID0) and (board[8] = ID0) then IsWin := ID0;
        if (board[0] = ID0) and (board[4] = ID0) and (board[8] = ID0) then IsWin := ID0;
        if (board[2] = ID0) and (board[4] = ID0) and (board[6] = ID0) then IsWin := ID0;
    end;
end;


procedure GameLevel1;
var
    rand0: integer;
    
begin
    randomize;
    rand0 := random(9);
    
    if (board[rand0] = IDEMPTY) then
    begin
        queue := IDX;
        counter := counter + 1;
        board[rand0] := ID0;
    end
    else
    begin
        GameLevel1;
    end;
end;


procedure GameLevel2;
var
    cmap: array[0..24, 0..3] of integer;
    b_ret: boolean;
    
begin
    b_ret := False;
    
    cmap[0, 0] := 0;    cmap[0, 1] := 1;    cmap[0, 2] := 2;
    cmap[1, 0] := 0;    cmap[1, 1] := 2;    cmap[1, 2] := 1;
    cmap[2, 0] := 1;    cmap[2, 1] := 2;    cmap[2, 2] := 0;
    cmap[3, 0] := 3;    cmap[3, 1] := 4;    cmap[3, 2] := 5;
    cmap[4, 0] := 3;    cmap[4, 1] := 5;    cmap[4, 2] := 4;
    cmap[5, 0] := 4;    cmap[5, 1] := 5;    cmap[5, 2] := 3;
    cmap[6, 0] := 6;    cmap[6, 1] := 7;    cmap[6, 2] := 8;
    cmap[7, 0] := 6;    cmap[7, 1] := 8;    cmap[7, 2] := 7;
    cmap[8, 0] := 7;    cmap[8, 1] := 8;    cmap[8, 2] := 6;
    cmap[9, 0] := 0;    cmap[9, 1] := 3;    cmap[9, 2] := 6;
    cmap[10, 0] := 0;  cmap[10, 1] := 6;   cmap[10, 2] := 3;
    cmap[11, 0] := 3;  cmap[11, 1] := 6;   cmap[11, 2] := 0;
    cmap[12, 0] := 1;  cmap[12, 1] := 4;   cmap[12, 2] := 7;
    cmap[13, 0] := 1;  cmap[13, 1] := 7;   cmap[13, 2] := 4;
    cmap[14, 0] := 4;  cmap[14, 1] := 7;   cmap[14, 2] := 1;
    cmap[15, 0] := 2;  cmap[15, 1] := 5;   cmap[15, 2] := 8;
    cmap[16, 0] := 2;  cmap[16, 1] := 8;   cmap[16, 2] := 5;
    cmap[17, 0] := 5;  cmap[17, 1] := 8;   cmap[17, 2] := 2;
    cmap[18, 0] := 0;  cmap[18, 1] := 4;   cmap[18, 2] := 8;
    cmap[19, 0] := 0;  cmap[19, 1] := 8;   cmap[19, 2] := 4;
    cmap[20, 0] := 4;  cmap[20, 1] := 8;   cmap[20, 2] := 0;
    cmap[21, 0] := 2;  cmap[21, 1] := 4;   cmap[21, 2] := 6;
    cmap[22, 0] := 2;  cmap[22, 1] := 6;   cmap[22, 2] := 4;
    cmap[23, 0] := 4;  cmap[23, 1] := 6;   cmap[23, 2] := 2;
    
    queue := IDX;
    
    // Доставляєм виграшну комбінацію.
    for i := 0 to 23 do
    begin
        if (board[cmap[i, 0]] = ID0) and (board[cmap[i, 1]] = ID0) and (board[cmap[i, 2]] = IDEMPTY) and (b_ret = False) then
        begin
            counter := counter + 1;
            board[cmap[i, 2]] := ID0;
            b_ret := True;
        end;
    end;
    
    // Якшо виграшної комбінації для '0' немає, а для 'X' є, то мішаєм виграти супротивнику.
    for i := 0 to 23 do
    begin
        if (board[cmap[i, 0]] = IDX) and (board[cmap[i, 1]] = IDX) and (board[cmap[i, 2]] = IDEMPTY) and (b_ret = False) then
        begin
            counter := counter + 1;
            board[cmap[i, 2]] := ID0;
            b_ret := True;
        end;
    end;
    
    // Якщо немає ніякої виграшної комбінації, то знаходимо рандомне 0.
    if (b_ret = False) then
        GameLevel1;
end;


procedure PlayGame;
var
    key: integer;
    win: integer;
    win_msg: array[0..3] of string;
    tmp_msg: string;
    
begin
    key := keyToAction(gkey);
    win := IsWin;
    
    win_msg[IDX] := 'Виграв X';
    win_msg[ID0] := 'Виграв 0';
    win_msg[IDEMPTY] := 'Нічия';
    
    DrawBoard;
    
    SetColor(255, 255, 255);
    DrawRect(GetWidth / 2 - 50, GetHeight - 45, 100, 40);
    DrawRect(GetWidth / 2 - 50, GetHeight - 45, 40, 40);
    
    if (queue = IDX) then DrawText('X', GetWidth / 2 - 30 - GetStringWidth('X') / 2, GetHeight - 25 - GetStringHeight('X') / 2);
    if (queue = ID0) then DrawText('0', GetWidth / 2 - 30 - GetStringWidth('X') / 2, GetHeight - 25 - GetStringHeight('0') / 2);
    
    tmp_msg := 'X: ' + IntegerToString(counterX);
    DrawText(tmp_msg, GetWidth / 2, GetHeight - 35 - GetStringHeight(tmp_msg) / 2);
    tmp_msg := '0: ' + IntegerToString(counter0);
    DrawText(tmp_msg, GetWidth / 2, GetHeight - 15 - GetStringHeight(tmp_msg) / 2);
    
    if (win = IDX) or (win = ID0) or ((win = IDEMPTY) and (counter = 9)) then
    begin
        x := GetWidth / 2 - GetStringWidth(win_msg[win]) / 2 - 10;
        y := GetWidth / 2 - GetStringHeight(win_msg[win]) / 2 - 5;
        w := GetStringWidth(win_msg[win]) + 20;
        h := GetStringHeight(win_msg[win]) + 10;
        
        SetColor(50, 50, 50);
        FillRect(x, y, w, h);
        SetColor(255, 255, 255);
        DrawRect(x, y, w, h);
        
        DrawText(win_msg[win], GetWidth / 2 - GetStringWidth(win_msg[win]) / 2, GetWidth / 2 - GetStringHeight(win_msg[win]) / 2);
        
        if (key = GA_FIRE) then
        begin
            counter := 0;
            queue := IDX;
            for i := 0 to 8 do
                board[i] := IDEMPTY;
            key := GA_NONE;
            gkey := KE_NONE;
            cursor_pos := 0;
        end;
    end;
    
    if (win = IDEMPTY) and (counter < 9) then
    begin
        SetColor(255, 0, 0);
        DrawRect(cells[cursor_pos, 0] + 2, cells[cursor_pos, 1] + 2, cell_size - 4, cell_size - 4);
        
        if (key = GA_UP) then
        begin
            if ((cursor_pos = 1) or (cursor_pos = 2)) then
                cursor_pos := cursor_pos + 5;
            else
                cursor_pos := cursor_pos - 3;
        end;
        
        if (key = GA_DOWN) then
        begin
            if ((cursor_pos = 6) or (cursor_pos = 7)) then
                cursor_pos := cursor_pos - 5;
            else 
                cursor_pos := cursor_pos + 3;
        end;
        
        if (key = GA_LEFT) then
            cursor_pos := cursor_pos - 1;
        
        if (key = GA_RIGHT) then
            cursor_pos := cursor_pos + 1;
        
        if (cursor_pos < 0) then cursor_pos := 0;
        if (cursor_pos >= 9) then cursor_pos := 8;
        
        if (key = GA_FIRE) then
        begin
            if (board[cursor_pos] = IDEMPTY) then
            begin
                if (queue = IDX) then
                begin
                    board[cursor_pos] := IDX;
                    counter := counter + 1;
                    queue := ID0;
                end
                else if (queue = ID0) then
                begin
                    board[cursor_pos] := ID0;
                    counter := counter + 1;
                    queue := IDX;
                end
                
                win := IsWin;
                
                if (counter < 9) and (win = IDEMPTY) then
                begin
                    if (level = 1) then GameLevel1;
                    if (level = 2) then GameLevel2;
                end;
                
                win := IsWin;
                
                if (win = IDX) then counterX := counterX + 1;
                if (win = ID0) then counter0 := counter0 + 1;
                
            end;
        end;
    end;
end;


procedure ShowMenu;
var
    key: integer;

const
    caption = 'Tic-Tac-Toe';
    
begin
    key := KeyToAction(gkey);
    
    if (menu_item = 0) then menu_item := 1;
    if (menu_item > 4) then menu_item := 4;
    
    SetColor(230, 30, 30);
    DrawText(caption, GetWidth / 2 - GetStringWidth(caption) / 2, 25 - GetStringHeight(caption) / 2);
    
    DrawImage(menu_bckg, GetWidth / 2 - GetImageWidth(menu_bckg) / 2, 50);
    
    for i := 1 to 4 do
    begin
        if (menu_item = i) then
        begin
            DrawImage(menu_imageOn, GetWidth / 2 - GetImageWidth(menu_imageOn) / 2, 20 + i * 50);
            SetColor(255, 255, 255);
        end
        else
        begin
            DrawImage(menu_imageOff, GetWidth / 2 - GetImageWidth(menu_imageOff) / 2, 20 + i * 50);
            SetColor(150, 150, 150);
        end;
        DrawText(menu_strings[i], GetWidth / 2 - GetStringWidth(menu_strings[i]) / 2, (20 + i * 50) + GetImageHeight(menu_imageOn) / 2 - GetStringHeight(menu_strings[i]) / 2);
    end;
    
    if (key = GA_UP) then menu_item := menu_item - 1;
    if (key = GA_DOWN) then menu_item := menu_item + 1;
    if (key = GA_FIRE) then
    begin
        location := menu_item;
        gkey := KE_NONE;
    end;
end;


procedure ZeroVS;
begin
    // Онуляєм всі значення комірок.
    for i := 0 to 8 do
        board[i] := IDEMPTY;
    
    cursor_pos := 0;
    queue := IDX;
    counter := 0;
    counterX := 0;
    counter0 := 0;
    level := 0;
    
    location := 0;
    menu_item := 0;
    gkey := KE_NONE;
end;


begin
    // Розмір комірок.
    cell_size := GetWidth / 3;
    
    // Координати всіх комірок.
    cells[0, 0] := 0;                   cells[0, 1] := 0;
    cells[1, 0] := cell_size;        cells[1, 1] := 0;
    cells[2, 0] := cell_size * 2;   cells[2, 1] := 0;
    cells[3, 0] := 0;                   cells[3, 1] := cell_size;
    cells[4, 0] := cell_size;        cells[4, 1] := cell_size;
    cells[5, 0] := cell_size * 2;   cells[5, 1] := cell_size;
    cells[6, 0] := 0;                   cells[6, 1] := cell_size * 2;
    cells[7, 0] := cell_size;        cells[7, 1] := cell_size * 2;
    cells[8, 0] := cell_size * 2;   cells[8, 1] := cell_size * 2;
    
    menu_bckg := LoadImage('/menuBckg.png');
    menu_imageOn := LoadImage('/menuOn.png');
    menu_imageOff := LoadImage('/menuOff.png');
    
    menu_strings[1] := 'Легкий рівень';
    menu_strings[2] := 'Складний рівень';
    menu_strings[3] := 'Гра на двох';
    menu_strings[4] := 'Вихід';
    
    ZeroVS;
    
    repeat
        SetColor(50, 50, 50);
        FillRect(0, 0, GetWidth, GetHeight);
        
        gkey := GetKeyClicked;
        
        if (gkey = -6) or (gkey = -7) then ZeroVS;
        
        if (location = 0) then ShowMenu;
        if (location = 1) then
        begin
            level := 1;
            PlayGame;
        end;
        if (location = 2) then 
        begin
            level := 2;
            PlayGame;
        end;
        if (location = 3) then
        begin
            level := 0;
            PlayGame;
        end;
        if (location = 4) then Halt;
        
        Repaint;
        Delay(1);
    until False;
end.
 